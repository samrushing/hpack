# -*- Mode: Python -*-

# this file generates the 'huffman_table' in hpack.py
#  at first, I thought I would play with using different-sized
#  chunks of bits to make a series of tables... for example, the
#  smallest code is 5 bits, and the largest is 30.  This invites
#  a code divided into 5-bit chunks.
# For now, I'm going to stick to the 1-bit code (i.e., a binary tree)
#  since this leads to a very compact ASCII representation.

# this table is built from rfc????, the HPACK spec.
codes = [
    '1111111111000',
    '11111111111111111011000',
    '1111111111111111111111100010',
    '1111111111111111111111100011',
    '1111111111111111111111100100',
    '1111111111111111111111100101',
    '1111111111111111111111100110',
    '1111111111111111111111100111',
    '1111111111111111111111101000',
    '111111111111111111101010',
    '111111111111111111111111111100',
    '1111111111111111111111101001',
    '1111111111111111111111101010',
    '111111111111111111111111111101',
    '1111111111111111111111101011',
    '1111111111111111111111101100',
    '1111111111111111111111101101',
    '1111111111111111111111101110',
    '1111111111111111111111101111',
    '1111111111111111111111110000',
    '1111111111111111111111110001',
    '1111111111111111111111110010',
    '111111111111111111111111111110',
    '1111111111111111111111110011',
    '1111111111111111111111110100',
    '1111111111111111111111110101',
    '1111111111111111111111110110',
    '1111111111111111111111110111',
    '1111111111111111111111111000',
    '1111111111111111111111111001',
    '1111111111111111111111111010',
    '1111111111111111111111111011',
    '010100',
    '1111111000',
    '1111111001',
    '111111111010',
    '1111111111001',
    '010101',
    '11111000',
    '11111111010',
    '1111111010',
    '1111111011',
    '11111001',
    '11111111011',
    '11111010',
    '010110',
    '010111',
    '011000',
    '00000',
    '00001',
    '00010',
    '011001',
    '011010',
    '011011',
    '011100',
    '011101',
    '011110',
    '011111',
    '1011100',
    '11111011',
    '111111111111100',
    '100000',
    '111111111011',
    '1111111100',
    '1111111111010',
    '100001',
    '1011101',
    '1011110',
    '1011111',
    '1100000',
    '1100001',
    '1100010',
    '1100011',
    '1100100',
    '1100101',
    '1100110',
    '1100111',
    '1101000',
    '1101001',
    '1101010',
    '1101011',
    '1101100',
    '1101101',
    '1101110',
    '1101111',
    '1110000',
    '1110001',
    '1110010',
    '11111100',
    '1110011',
    '11111101',
    '1111111111011',
    '1111111111111110000',
    '1111111111100',
    '11111111111100',
    '100010',
    '111111111111101',
    '00011',
    '100011',
    '00100',
    '100100',
    '00101',
    '100101',
    '100110',
    '100111',
    '00110',
    '1110100',
    '1110101',
    '101000',
    '101001',
    '101010',
    '00111',
    '101011',
    '1110110',
    '101100',
    '01000',
    '01001',
    '101101',
    '1110111',
    '1111000',
    '1111001',
    '1111010',
    '1111011',
    '111111111111110',
    '11111111100',
    '11111111111101',
    '1111111111101',
    '1111111111111111111111111100',
    '11111111111111100110',
    '1111111111111111010010',
    '11111111111111100111',
    '11111111111111101000',
    '1111111111111111010011',
    '1111111111111111010100',
    '1111111111111111010101',
    '11111111111111111011001',
    '1111111111111111010110',
    '11111111111111111011010',
    '11111111111111111011011',
    '11111111111111111011100',
    '11111111111111111011101',
    '11111111111111111011110',
    '111111111111111111101011',
    '11111111111111111011111',
    '111111111111111111101100',
    '111111111111111111101101',
    '1111111111111111010111',
    '11111111111111111100000',
    '111111111111111111101110',
    '11111111111111111100001',
    '11111111111111111100010',
    '11111111111111111100011',
    '11111111111111111100100',
    '111111111111111011100',
    '1111111111111111011000',
    '11111111111111111100101',
    '1111111111111111011001',
    '11111111111111111100110',
    '11111111111111111100111',
    '111111111111111111101111',
    '1111111111111111011010',
    '111111111111111011101',
    '11111111111111101001',
    '1111111111111111011011',
    '1111111111111111011100',
    '11111111111111111101000',
    '11111111111111111101001',
    '111111111111111011110',
    '11111111111111111101010',
    '1111111111111111011101',
    '1111111111111111011110',
    '111111111111111111110000',
    '111111111111111011111',
    '1111111111111111011111',
    '11111111111111111101011',
    '11111111111111111101100',
    '111111111111111100000',
    '111111111111111100001',
    '1111111111111111100000',
    '111111111111111100010',
    '11111111111111111101101',
    '1111111111111111100001',
    '11111111111111111101110',
    '11111111111111111101111',
    '11111111111111101010',
    '1111111111111111100010',
    '1111111111111111100011',
    '1111111111111111100100',
    '11111111111111111110000',
    '1111111111111111100101',
    '1111111111111111100110',
    '11111111111111111110001',
    '11111111111111111111100000',
    '11111111111111111111100001',
    '11111111111111101011',
    '1111111111111110001',
    '1111111111111111100111',
    '11111111111111111110010',
    '1111111111111111101000',
    '1111111111111111111101100',
    '11111111111111111111100010',
    '11111111111111111111100011',
    '11111111111111111111100100',
    '111111111111111111111011110',
    '111111111111111111111011111',
    '11111111111111111111100101',
    '111111111111111111110001',
    '1111111111111111111101101',
    '1111111111111110010',
    '111111111111111100011',
    '11111111111111111111100110',
    '111111111111111111111100000',
    '111111111111111111111100001',
    '11111111111111111111100111',
    '111111111111111111111100010',
    '111111111111111111110010',
    '111111111111111100100',
    '111111111111111100101',
    '11111111111111111111101000',
    '11111111111111111111101001',
    '1111111111111111111111111101',
    '111111111111111111111100011',
    '111111111111111111111100100',
    '111111111111111111111100101',
    '11111111111111101100',
    '111111111111111111110011',
    '11111111111111101101',
    '111111111111111100110',
    '1111111111111111101001',
    '111111111111111100111',
    '111111111111111101000',
    '11111111111111111110011',
    '1111111111111111101010',
    '1111111111111111101011',
    '1111111111111111111101110',
    '1111111111111111111101111',
    '111111111111111111110100',
    '111111111111111111110101',
    '11111111111111111111101010',
    '11111111111111111110100',
    '11111111111111111111101011',
    '111111111111111111111100110',
    '11111111111111111111101100',
    '11111111111111111111101101',
    '111111111111111111111100111',
    '111111111111111111111101000',
    '111111111111111111111101001',
    '111111111111111111111101010',
    '111111111111111111111101011',
    '1111111111111111111111111110',
    '111111111111111111111101100',
    '111111111111111111111101101',
    '111111111111111111111101110',
    '111111111111111111111101111',
    '111111111111111111111110000',
    '11111111111111111111101110',
    '111111111111111111111111111111',
]

codes = list (enumerate (codes))

def build_tree (codes, width=5, depth=0):
    d = {}
    # collect all the subtrees under each 
    #   unique prefix of <width> bits.
    for char, code in codes:
        c0, c1 = code[:width], code[width:]
        n = int (c0, 2)
        x = d.setdefault (n, [])
        x.append ((char, c1))
    # if width == 5, r has 32 entries.
    r = [None] * (1 << width)
    for n, subs in d.items():
        if len(subs) == 1:
            # this is a leaf node.
            (char, code) = subs[0]
            assert (code == '')
            r[n] = char
        else:
            # this is a subtree.
            r[n] = build_tree (subs, width, depth+1)
    return r

# print a table of width, rough-size-of-table-in-source...
for width in range (1, 9):
    print width, len (repr (build_tree (codes, width)))

# ... which shows that the binary tree is the most
#   compact (no surprise, I suppose).

# Note: everything below assumes a width of 1 (i.e., binary tree).
# ok, this is the data structure we *want*.
print build_tree (codes, 1)
# but placing it in the source code like that is a bit
#  of a mess.  let's come up with a more compact representation.
# instead: every time there's a split, let's put a '.' char.
# since all the splits are binary...
# so, we start off with:
# [[[[[48, 49] ...
# this should become ....30313261
# for example,
#   [[48, 49], [50, 97]]
# should become
#   ..30313261
# and we should be able to convert back as well.

def hexint (n):
    if n == 256:
        # EOS code.
        return 'Z'
    else:
        return '%02x' % (n,)

def to_ascii (t):
    if isinstance (t, int):
        return hexint (t)
    else:
        l, r = t
        return '.' + to_ascii (l) + to_ascii (r)

def from_ascii (s, pos=0):
    if s[pos] == '.':
        pos += 1
        l, pos = from_ascii (s, pos)
        r, pos = from_ascii (s, pos)
        return [l, r], pos
    elif s[pos] == 'Z':
        return 256, pos + 1
    else:
        return int(s[pos:pos+2], 16), pos + 2

t0 = build_tree (codes, 1)
print t0
a0 = to_ascii (t0)
print a0
t1, pos = from_ascii (a0, 0)
assert (pos == len(a0))
